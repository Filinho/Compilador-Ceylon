KW_CLASS class
ID Ponto
L_PAREN (
KW_SHARED shared
TYPE_INTEGER Integer
ID x
COMMA ,
KW_SHARED shared
TYPE_INTEGER Integer
ID y
R_PAREN )
L_BRACE {
R_BRACE }
KW_CLASS class
ID Triangulo
L_PAREN (
KW_SHARED shared
ID Ponto
ID a
COMMA ,
KW_SHARED shared
ID Ponto
ID b
COMMA ,
KW_SHARED shared
ID Ponto
ID c
COMMA ,
KW_SHARED shared
TYPE_INTEGER Integer
ID cor
R_PAREN )
L_BRACE {
R_BRACE }
KW_SHARED shared
TYPE_FLOAT Float
ID func
L_PAREN (
ID Ponto
L_BRACKET [
R_BRACKET ]
ID v
COMMA ,
TYPE_INTEGER Integer
ID n
COMMA ,
ID Triangulo
ID T
R_PAREN )
L_BRACE {
KW_IF if
L_PAREN (
ID n
OP_LESS_EQUAL <=
LIT_INT 0
R_PAREN )
L_BRACE {
KW_RETURN return
LIT_FLOAT 1.0
SEMICOLON ;
R_BRACE }
KW_ELSE else
KW_IF if
L_PAREN (
ID n
OP_EQUAL ==
LIT_INT 1
R_PAREN )
L_BRACE {
KW_RETURN return
LIT_FLOAT 1.01
OP_ADD +
ID v
L_BRACKET [
LIT_INT 0
R_BRACKET ]
OP_MEMBER .
ID x
OP_MEMBER .
ID float
OP_DIV /
LIT_FLOAT 1.0e2
OP_ADD +
ID v
L_BRACKET [
LIT_INT 0
R_BRACKET ]
OP_MEMBER .
ID y
OP_MEMBER .
ID float
OP_DIV /
LIT_FLOAT 0.1e-2
OP_SUB -
ID T
OP_MEMBER .
ID a
OP_MEMBER .
ID x
OP_MEMBER .
ID float
OP_MUL *
ID T
OP_MEMBER .
ID a
OP_MEMBER .
ID x
OP_MEMBER .
ID float
OP_ADD +
ID T
OP_MEMBER .
ID b
OP_MEMBER .
ID y
OP_MEMBER .
ID float
OP_MUL *
ID T
OP_MEMBER .
ID c
OP_MEMBER .
ID x
OP_MEMBER .
ID float
SEMICOLON ;
R_BRACE }
KW_VARIABLE variable
TYPE_FLOAT Float
ID res
OP_SPECIFY =
LIT_FLOAT 0.25e-13
SEMICOLON ;
KW_VARIABLE variable
TYPE_INTEGER Integer
ID i
OP_SPECIFY =
ID n
OP_SUB -
LIT_INT 1
SEMICOLON ;
KW_WHILE while
L_PAREN (
ID i
OP_GREATER_EQUAL >=
LIT_INT 0
OP_AND &&
ID v
L_BRACKET [
ID i
R_BRACKET ]
OP_MEMBER .
ID x
OP_GREATER >
LIT_INT 0
R_PAREN )
L_BRACE {
TYPE_FLOAT Float
ID temp
OP_SPECIFY =
ID v
L_BRACKET [
ID i
R_BRACKET ]
OP_MEMBER .
ID y
OP_MEMBER .
ID float
OP_MUL *
ID v
L_BRACKET [
ID i
R_BRACKET ]
OP_MEMBER .
ID x
OP_MEMBER .
ID float
OP_REMAINDER %
LIT_FLOAT 123.0
SEMICOLON ;
KW_IF if
L_PAREN (
ID temp
OP_LESS <
LIT_FLOAT 0.0
R_PAREN )
L_BRACE {
ID res
OP_SPECIFY =
ID res
OP_SUB -
ID res
OP_MUL *
LIT_FLOAT 2.0e-2
OP_ADD +
ID func
L_PAREN (
ID v
COMMA ,
ID n
OP_SUB -
LIT_INT 1
COMMA ,
ID T
R_PAREN )
OP_MUL *
ID temp
OP_SUB -
ID T
OP_MEMBER .
ID a
OP_MEMBER .
ID y
OP_MEMBER .
ID float
OP_MUL *
ID T
OP_MEMBER .
ID cor
OP_MEMBER .
ID float
SEMICOLON ;
R_BRACE }
KW_ELSE else
L_BRACE {
ID res
OP_SPECIFY =
ID res
OP_ADD +
ID res
OP_MUL *
LIT_FLOAT 0.3e3
OP_ADD +
ID func
L_PAREN (
ID v
COMMA ,
ID n
OP_SUB -
LIT_INT 2
COMMA ,
ID T
R_PAREN )
OP_MUL *
ID temp
OP_ADD +
ID T
OP_MEMBER .
ID c
OP_MEMBER .
ID x
OP_MEMBER .
ID float
OP_MUL *
ID T
OP_MEMBER .
ID cor
OP_MEMBER .
ID float
SEMICOLON ;
ID print
L_PAREN (
LIT_STRING "Estranho, ne?"
R_PAREN )
SEMICOLON ;
R_BRACE }
ID i
OP_SPECIFY =
ID i
OP_SUB -
LIT_INT 1
SEMICOLON ;
R_BRACE }
KW_RETURN return
ID res
SEMICOLON ;
R_BRACE }
KW_SHARED shared
TYPE_INTEGER Integer
ID F2
L_PAREN (
ID Triangulo
ID T
R_PAREN )
L_BRACE {
KW_VARIABLE variable
TYPE_INTEGER Integer
ID A
OP_SPECIFY =
LIT_INT 0
SEMICOLON ;
KW_VARIABLE variable
TYPE_FLOAT Float
L_BRACKET [
R_BRACKET ]
ID soma
OP_SPECIFY =
ID arrayOfSize
L_PAREN (
LIT_INT 10
COMMA ,
LIT_FLOAT 0.0
R_PAREN )
SEMICOLON ;
KW_IF if
L_PAREN (
L_PAREN (
ID T
OP_MEMBER .
ID a
OP_MEMBER .
ID x
OP_GREATER_EQUAL >=
LIT_INT 10
OP_OR ||
ID T
OP_MEMBER .
ID b
OP_MEMBER .
ID y
OP_GREATER >
LIT_INT 20
OP_OR ||
ID T
OP_MEMBER .
ID a
OP_MEMBER .
ID y
OP_LESS <
LIT_INT 30
OP_OR ||
ID T
OP_MEMBER .
ID b
OP_MEMBER .
ID x
OP_LESS_EQUAL <=
LIT_INT 50
R_PAREN )
OP_AND &&
OP_NOT !
L_PAREN (
ID T
OP_MEMBER .
ID c
OP_MEMBER .
ID x
OP_NOT_EQUAL !=
LIT_INT 90
OP_OR ||
ID T
OP_MEMBER .
ID c
OP_MEMBER .
ID y
OP_EQUAL ==
LIT_INT 0
R_PAREN )
R_PAREN )
L_BRACE {
KW_RETURN return
LIT_INT 10
OP_REMAINDER %
LIT_INT 3
SEMICOLON ;
R_BRACE }
KW_ELSE else
L_BRACE {
ID A
OP_SPECIFY =
LIT_INT 1
SEMICOLON ;
R_BRACE }
KW_WHILE while
L_PAREN (
ID A
OP_LESS <
LIT_INT 10
R_PAREN )
L_BRACE {
KW_VARIABLE variable
TYPE_INTEGER Integer
ID total
OP_SPECIFY =
LIT_INT 0
SEMICOLON ;
ID total
OP_SPECIFY =
ID total
OP_ADD +
ID T
OP_MEMBER .
ID c
OP_MEMBER .
ID x
OP_MUL *
ID T
OP_MEMBER .
ID c
OP_MEMBER .
ID y
SEMICOLON ;
ID total
OP_SPECIFY =
ID total
OP_ADD +
ID T
OP_MEMBER .
ID b
OP_MEMBER .
ID x
OP_MUL *
ID T
OP_MEMBER .
ID a
OP_MEMBER .
ID y
SEMICOLON ;
ID total
OP_SPECIFY =
ID total
OP_ADD +
ID T
OP_MEMBER .
ID a
OP_MEMBER .
ID x
OP_MUL *
ID T
OP_MEMBER .
ID b
OP_MEMBER .
ID y
SEMICOLON ;
ID soma
L_BRACKET [
ID A
R_BRACKET ]
OP_SPECIFY =
L_PAREN (
ID total
OP_REMAINDER %
LIT_INT 100
R_PAREN )
OP_MEMBER .
ID float
SEMICOLON ;
ID A
OP_SPECIFY =
ID A
OP_ADD +
LIT_INT 1
SEMICOLON ;
R_BRACE }
KW_RETURN return
LIT_INT 0
SEMICOLON ;
R_BRACE }
